{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["geoMarkerStyle","Style","image","CircleStyle","radius","fill","Fill","color","stroke","Stroke","width","drawCircleInMeter","pos","circle","Circle","circleFeature","Feature","vectorSource","VectorSource","features","projection","VectorLayer","source","style","drawPosition","event","geolocation","position","getPosition","vectorContext","getVectorContext","currentPoint","Point","feature","drawFeature","changeCirclePosition","center","circleLayer","getSource","clear","addFeatures","App","deferredPrompt","useState","zoneOk","setZoneOk","showInstallPromotion","setShowInstallPromotion","circleCenter","setCircleCenter","setPosition","setGeolocation","setCircleLayer","map","setMap","init","a","OSM","tileLayer","Tile","fromLonLat","Map","target","layers","view","View","zoom","controls","Geolocation","trackingOptions","enableHighAccuracy","on","useEffect","getTracking","setTracking","error","console","warn","pt1","turf","toLonLat","pt2","isInZone","window","navigator","vibrate","render","addEventListener","e","preventDefault","className","id","onClick","prompt","userChoice","then","choiceResult","outcome","log","Boolean","location","hostname","match","ReactDOM","StrictMode","document","getElementById","serviceWorker","ready","registration","unregister","catch","message"],"mappings":"2YA+JA,IAAMA,EAAiB,IAAIC,IAAM,CAC/BC,MAAO,IAAIC,IAAY,CACrBC,OAAQ,EACRC,KAAM,IAAIC,IAAK,CAACC,MAAO,UACvBC,OAAQ,IAAIC,IAAO,CACjBF,MAAO,QACPG,MAAO,QAMTC,EAAoB,SAACC,EAAKR,GAC5B,IAAIS,EAAS,IAAIC,IAAOF,EAAKR,GACzBW,EAAgB,IAAIC,IAAQH,GAC5BI,EAAe,IAAIC,IAAa,CAClCC,SAAU,CAACJ,GACXK,WAAY,cAGd,OAAO,IAAIC,IAAY,CACrBC,OAAQL,EACRM,MAAO,CACP,IAAItB,IAAM,CACNO,OAAQ,IAAIC,IAAO,CACfF,MAAO,OACPG,MAAO,IAEXL,KAAM,IAAIC,IAAK,CACXC,MAAO,+BAOnB,SAASiB,EAAaC,EAAOC,GAC3B,IAAIC,EAAWD,EAAYE,cAC3B,GAAKD,EAAL,CAEA,IAAIE,EAAgBC,YAAiBL,GACjCM,EAAe,IAAIC,IAAML,GACzBM,EAAU,IAAIjB,IAAQe,GAC1BF,EAAcK,YAAYD,EAASjC,IAGrC,IAAImC,EAAuB,SAASC,EAAQhC,EAAQiC,GAClD,IAAIxB,EAAS,IAAIC,IAAOsB,EAAQhC,GAC5BW,EAAgB,IAAIC,IAAQH,GAChCwB,EAAYC,YAAYC,QACxBF,EAAYC,YAAYE,YAAY,CAACzB,KAMxB0B,EAhMf,WAAgB,IA+FVC,EA/FS,EACeC,oBAAS,GADxB,mBACNC,EADM,KACEC,EADF,OAE2CF,oBAAS,GAFpD,mBAENG,EAFM,KAEgBC,EAFhB,OAG2BJ,mBAAS,MAHpC,mBAGNK,EAHM,KAGQC,EAHR,OAImBN,mBAAS,MAJ5B,mBAINhB,EAJM,KAIIuB,EAJJ,OAKyBP,mBAAS,MALlC,mBAKNjB,EALM,KAKOyB,EALP,OAMyBR,mBAAS,MANlC,mBAMNN,EANM,KAMOe,EANP,OAOST,mBAAS,MAPlB,mBAONU,EAPM,KAODC,EAPC,KASPC,EAAI,uCAAG,oCAAAC,EAAA,sDACLlC,EAAS,IAAImC,IACbC,EAAY,IAAIC,IAAK,CACzBrC,OAAQA,IAGJe,EAAc1B,EAAkBiD,YAAW,CAAC,SAAU,YAAa,MAErEP,EAAM,IAAIQ,IAAI,CAChBC,OAAQ,MACRC,OAAQ,CACNL,EAEArB,GAEF2B,KAAM,IAAIC,IAAK,CACb7C,WAAY,YACZgB,OAAQwB,YAAW,CAAC,OAAQ,UAC5BM,KAAM,KAERC,SAAU,KAGRzC,EAAc,IAAI0C,IAAY,CAEhCC,gBAAiB,CACfC,oBAAoB,GAEtBlD,WAAY,cAGdsC,EAAUa,GAAG,cAAc,SAAC9C,GAAD,OAAWD,EAAaC,EAAOC,MAE1DyB,EAAezB,GACf0B,EAAef,GACfiB,EAAOD,GAnCI,2CAAH,qDAmHV,OA7EAmB,qBAAU,WACRjB,MACC,IAEHiB,qBAAU,WACH9C,IAAeA,EAAY+C,gBAGhC/C,EAAYgD,aAAY,GAGxBhD,EAAY6C,GAAG,UAAU,WACvBrB,EAAYxB,EAAYE,kBAI1BF,EAAY6C,GAAG,SAAS,SAAUI,GAChCC,QAAQC,KAAK,oBAAqBF,SAEnC,CAACjD,EAAa2B,IAEjBmB,qBAAU,WACJxB,GACFb,EAAqBa,EAAc,KAAMX,KAC1C,CAACW,EAAcX,IAElBmC,qBAAU,WACR,GAAK7C,GAAaqB,EAAlB,CAGA,IAAM8B,EAAMC,QAAWC,YAASrD,IAC1BsD,EAAMF,QAAWC,YAAShC,IAE1BkC,EADWH,WAAcD,EAAKG,GACR,EAGxBC,IAAatC,GACfuC,OAAOC,UAAUC,QAAQ,KAE3BxC,EAAUqC,GAEV7B,EAAIiC,YACH,CAAC3D,EAAUqB,IAOdmC,OAAOI,iBAAiB,uBAAuB,SAACC,GAE9CA,EAAEC,iBAEF/C,EAAiB8C,EAEjBzC,GAAwB,MAuBxB,yBAAK2C,UAAU,OACb,yBAAKC,GAAG,MAAMD,UAAU,QACxB,4BAAQA,WAAa9C,EAAS,UAAY,YAAc,gBACxD,yBAAK8C,UAAU,eAAeE,QARlC,WACE3C,EAAgBvB,EAAYE,iBAO1B,gBACCkB,EAAuB,4BAAQ4C,UAAU,iBAAiBE,QAxB/D,WAEE7C,GAAwB,GAExBL,EAAemD,SAEfnD,EAAeoD,WAAWC,MAAK,SAACC,GACD,aAAzBA,EAAaC,QACfrB,QAAQsB,IAAI,oCAEZtB,QAAQsB,IAAI,0CAcU,qBAAqF,OC5I/FC,QACW,cAA7BhB,OAAOiB,SAASC,UAEe,UAA7BlB,OAAOiB,SAASC,UAEhBlB,OAAOiB,SAASC,SAASC,MACvB,2DCZNC,IAASjB,OACP,kBAAC,IAAMkB,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDyHpB,kBAAmBtB,WACrBA,UAAUuB,cAAcC,MACrBb,MAAK,SAAAc,GACJA,EAAaC,gBAEdC,OAAM,SAAApC,GACLC,QAAQD,MAAMA,EAAMqC,a","file":"static/js/main.51d92d16.chunk.js","sourcesContent":["import React, { useEffect, useState } from 'react';\nimport './App.css';\nimport Map from 'ol/Map';\nimport View from 'ol/View';\nimport Tile from 'ol/layer/Tile';\nimport VectorLayer from 'ol/layer/Vector';\nimport VectorSource from 'ol/source/Vector';\nimport OSM from 'ol/source/OSM';\nimport { fromLonLat, toLonLat, getPointResolution } from 'ol/proj';\nimport GeoJSON from 'ol/format/GeoJSON';\nimport Style from 'ol/style/Style';\nimport Stroke from 'ol/style/Stroke';\nimport Fill from 'ol/style/Fill';\nimport CircleStyle from 'ol/style/Circle';\nimport Geolocation from 'ol/Geolocation';\nimport {getVectorContext} from 'ol/render';\nimport Point from 'ol/geom/Point';\nimport Circle from 'ol/geom/Circle';\n\nimport Feature from 'ol/Feature';\nimport * as turf from '@turf/turf'\n\n\nfunction App() {\n  const [zoneOk, setZoneOk] = useState(false);\n  const [showInstallPromotion, setShowInstallPromotion] = useState(false);\n  const [circleCenter, setCircleCenter] = useState(null);\n  const [position, setPosition] = useState(null);\n  const [geolocation, setGeolocation] = useState(null);\n  const [circleLayer, setCircleLayer] = useState(null);\n  const [map, setMap] = useState(null);\n\n  const init = async () => {\n    const source = new OSM();\n    const tileLayer = new Tile({\n      source: source\n    });\n\n    const circleLayer = drawCircleInMeter(fromLonLat([2.337242, 48.857351]), 1200);\n\n    var map = new Map({\n      target: 'map',\n      layers: [\n        tileLayer,\n        //maskZonesLayer,\n        circleLayer\n      ],\n      view: new View({\n        projection: 'EPSG:3857',\n        center: fromLonLat([2.3488, 48.8534]),\n        zoom: 13\n      }),\n      controls: []\n    });\n\n    var geolocation = new Geolocation({\n      // enableHighAccuracy must be set to true to have the heading value.\n      trackingOptions: {\n        enableHighAccuracy: true,\n      },\n      projection: 'EPSG:3857',\n    });\n\n    tileLayer.on('postrender', (event) => drawPosition(event, geolocation /*geolocation*/ ));\n\n    setGeolocation(geolocation);\n    setCircleLayer(circleLayer);\n    setMap(map);\n  }\n\n  useEffect(() => {\n    init();\n  }, []);\n\n  useEffect(() => {\n    if (!geolocation || geolocation.getTracking())\n      return;\n\n    geolocation.setTracking(true);\n\n    // update the HTML page when the position changes.\n    geolocation.on('change', () => {\n      setPosition(geolocation.getPosition());\n    });\n\n    // handle geolocation error.\n    geolocation.on('error', function (error) {\n      console.warn('geolocation error', error);\n    });\n  }, [geolocation, map]);\n\n  useEffect(() => {\n    if (circleCenter)\n      changeCirclePosition(circleCenter, 1500, circleLayer);\n  }, [circleCenter, circleLayer]);\n\n  useEffect(() => {\n    if (!position || !circleCenter)\n      return;\n\n    const pt1 = turf.point(toLonLat(position));\n    const pt2 = turf.point(toLonLat(circleCenter));\n    const distance = turf.distance(pt1, pt2);\n    const isInZone = distance < 1;\n\n    //vibrate on transition\n    if (isInZone && !zoneOk)\n      window.navigator.vibrate(300);\n\n    setZoneOk(isInZone);\n\n    map.render();\n  }, [position, circleCenter])\n\n\n  ///////////////////////\n  //PWA stuff to be moved\n\n  let deferredPrompt;\n  window.addEventListener('beforeinstallprompt', (e) => {\n    // Prevent the mini-infobar from appearing on mobile\n    e.preventDefault();\n    // Stash the event so it can be triggered later.\n    deferredPrompt = e;\n    // Update UI notify the user they can install the PWA\n    setShowInstallPromotion(true);\n  });\n\n  function installPwa() {\n    // Hide the app provided install promotion\n    setShowInstallPromotion(false);\n    // Show the install prompt\n    deferredPrompt.prompt();\n    // Wait for the user to respond to the prompt\n    deferredPrompt.userChoice.then((choiceResult) => {\n      if (choiceResult.outcome === 'accepted') {\n        console.log('User accepted the install prompt');\n      } else {\n        console.log('User dismissed the install prompt');\n      }\n    });\n  }\n\n  function changeCirclePositionWithCurrentPosition() {\n    setCircleCenter(geolocation.getPosition());\n  }\n\n  return (\n    <div className=\"app\">\n      <div id=\"map\" className=\"map\"></div>\n      <header className={ (zoneOk ? 'zone-ok' : 'zone-nok') + ' app-header' }></header>\n      <div className=\"use-position\" onClick={changeCirclePositionWithCurrentPosition}>Use Position</div>\n      {showInstallPromotion ? <footer className='install-footer' onClick={installPwa}>Install as an App</footer> : null}\n\n    </div>\n  );\n}\n\n\nconst geoMarkerStyle = new Style({\n  image: new CircleStyle({\n    radius: 7,\n    fill: new Fill({color: 'black'}),\n    stroke: new Stroke({\n      color: 'white',\n      width: 2,\n    }),\n  })\n});\n\n\nvar drawCircleInMeter = (pos, radius) => {\n  var circle = new Circle(pos, radius);\n  var circleFeature = new Feature(circle);\n  var vectorSource = new VectorSource({\n    features: [circleFeature],\n    projection: 'EPSG:3857',\n  });\n\n  return new VectorLayer({\n    source: vectorSource,\n    style: [\n    new Style({\n        stroke: new Stroke({\n            color: 'blue',\n            width: 3\n        }),\n        fill: new Fill({\n            color: 'rgba(0, 0, 255, 0.1)'\n        })\n    })]\n  });\n}\n\n\nfunction drawPosition(event, geolocation) {\n  let position = geolocation.getPosition();\n  if (!position)\n    return;\n  var vectorContext = getVectorContext(event);\n  var currentPoint = new Point(position);\n  var feature = new Feature(currentPoint);\n  vectorContext.drawFeature(feature, geoMarkerStyle);\n};\n\nvar changeCirclePosition = function(center, radius, circleLayer) {\n  var circle = new Circle(center, radius);\n  var circleFeature = new Feature(circle);\n  circleLayer.getSource().clear();\n  circleLayer.getSource().addFeatures([circleFeature]);\n};\n\n\n//Test lat long : (48.857351 , 2.337242)\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}