{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["maskZoneStyle","Style","fill","Fill","color","geoMarkerStyle","image","CircleStyle","radius","stroke","Stroke","width","fetchMaskZones","a","fetch","response","json","res","records","map","record","fields","geo_shape","coordinates","x","fromLonLat","drawPosition","event","geolocation","position","getPosition","vectorContext","getVectorContext","currentPoint","Point","feature","Feature","drawFeature","App","deferredPrompt","useState","shouldWearMask","setShouldWearMask","showInstallPromotion","setShowInstallPromotion","init","polygones","geojsonObject","maskZonesVectorSource","VectorSource","features","GeoJSON","readFeatures","maskZonesLayer","VectorLayer","source","style","OSM","Map","target","layers","Tile","view","View","projection","center","zoom","controls","Geolocation","trackingOptions","enableHighAccuracy","setTracking","on","pt","turf","isInZone","polygone","poly","window","navigator","vibrate","render","error","console","warn","useEffect","addEventListener","e","preventDefault","className","id","onClick","prompt","userChoice","then","choiceResult","outcome","log","Boolean","location","hostname","match","ReactDOM","StrictMode","document","getElementById","serviceWorker","ready","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.55f72882.chunk.js","sourcesContent":["import React, { useEffect, useState } from 'react';\nimport './App.css';\nimport Map from 'ol/Map';\nimport View from 'ol/View';\nimport Tile from 'ol/layer/Tile';\nimport VectorLayer from 'ol/layer/Vector';\nimport VectorSource from 'ol/source/Vector';\nimport OSM from 'ol/source/OSM';\nimport { fromLonLat } from 'ol/proj';\nimport GeoJSON from 'ol/format/GeoJSON';\nimport Style from 'ol/style/Style';\nimport Stroke from 'ol/style/Stroke';\nimport Fill from 'ol/style/Fill';\nimport CircleStyle from 'ol/style/Circle';\nimport Geolocation from 'ol/Geolocation';\nimport {getVectorContext} from 'ol/render';\nimport Point from 'ol/geom/Point';\nimport Feature from 'ol/Feature';\nimport * as turf from '@turf/turf'\n\nconst maskZoneStyle =\n  new Style({\n    fill: new Fill({\n      color: 'rgba(0, 0, 255, 0.3)',\n    }),\n  });\n\n  const geoMarkerStyle = new Style({\n  image: new CircleStyle({\n    radius: 7,\n    fill: new Fill({color: 'black'}),\n    stroke: new Stroke({\n      color: 'white',\n      width: 2,\n    }),\n  })\n});\n\nfunction App() {\n  const [shouldWearMask, setShouldWearMask] = useState(false);\n  const [showInstallPromotion, setShowInstallPromotion] = useState(false);\n\n\n  const init = async () => {\n    let polygones = await fetchMaskZones();\n\n    let geojsonObject = {\n      'type': 'FeatureCollection',\n      'crs': {\n        'type': 'name',\n        'properties': {\n          'name': 'EPSG:3857', //EPSG:3857\n          'center': [0, 0],\n        },\n      },\n      'features': [\n        {\n          'type': 'Feature',\n          'geometry': {\n            'type': 'Polygon',\n            'coordinates':\n              polygones,\n          },\n        },\n      ]\n    };\n\n    var maskZonesVectorSource = new VectorSource({\n      features: new GeoJSON().readFeatures(geojsonObject),\n    });\n\n    var maskZonesLayer = new VectorLayer({\n      source: maskZonesVectorSource,\n      style: maskZoneStyle,\n    });\n\n    const source = new OSM();\n\n    var map = new Map({\n      target: 'map',\n      layers: [\n        new Tile({\n          source: source\n        }),\n        maskZonesLayer,\n      ],\n      view: new View({\n        projection: 'EPSG:3857',\n        center: fromLonLat([2.3488, 48.8534]),\n        zoom: 13\n      }),\n      controls: []\n    });\n\n    var geolocation = new Geolocation({\n      // enableHighAccuracy must be set to true to have the heading value.\n      trackingOptions: {\n        enableHighAccuracy: true,\n      },\n      projection: 'EPSG:3857',\n    });\n\n    geolocation.setTracking(true);\n\n    // update the HTML page when the position changes.\n    geolocation.on('change', function () {\n      let position = geolocation.getPosition();\n      if (!position)\n        return;\n\n      var pt = turf.point(position);\n\n      var isInZone = false;\n      for (const polygone of polygones) {\n        var poly = turf.polygon([polygone]);\n        isInZone = isInZone || turf.booleanPointInPolygon(pt, poly);\n        if (isInZone) break;\n      }\n\n      //vibrate on transition\n      if (isInZone && !shouldWearMask)\n        window.navigator.vibrate(300);\n\n      setShouldWearMask(isInZone);\n\n      map.render();\n    });\n\n    // handle geolocation error.\n    geolocation.on('error', function (error) {\n     console.warn('geolocation error', error);\n    });\n\n    maskZonesLayer.on('postrender', (event) => drawPosition(event, geolocation /*geolocation*/ ));\n  }\n\n  useEffect(() => {\n    init();\n  }, []);\n\n  ///////////////////////\n  //PWA stuff to be moved\n\n  let deferredPrompt;\n  window.addEventListener('beforeinstallprompt', (e) => {\n    // Prevent the mini-infobar from appearing on mobile\n    e.preventDefault();\n    // Stash the event so it can be triggered later.\n    deferredPrompt = e;\n    // Update UI notify the user they can install the PWA\n    setShowInstallPromotion(true);\n  });\n\n  function installPwa() {\n    // Hide the app provided install promotion\n    setShowInstallPromotion(false);\n    // Show the install prompt\n    deferredPrompt.prompt();\n    // Wait for the user to respond to the prompt\n    deferredPrompt.userChoice.then((choiceResult) => {\n      if (choiceResult.outcome === 'accepted') {\n        console.log('User accepted the install prompt');\n      } else {\n        console.log('User dismissed the install prompt');\n      }\n    });\n  }\n\n  return (\n    <div className=\"app\">\n      <div id=\"map\" className=\"map\"></div>\n      <header className={ (shouldWearMask ? 'mask-on' : 'mask-off') + ' app-header' }></header>\n      {showInstallPromotion ? <footer className='install-footer' onClick={installPwa}>Install as an App</footer> : null}\n\n    </div>\n  );\n}\n\nasync function fetchMaskZones() {\n  var response = await fetch(\"https://opendata.paris.fr/api/records/1.0/search/?dataset=coronavirus-port-du-masque-obligatoire-lieux-places-et-marches&q=&rows=100&facet=nom_long&facet=ardt\");\n  var res = await response.json();\n  return res.records.map(record => record.fields.geo_shape.coordinates[0].map(x => (fromLonLat(x))));\n}\n\nfunction drawPosition(event, geolocation) {\n  let position = geolocation.getPosition();\n  if (!position)\n    return;\n  var vectorContext = getVectorContext(event);\n  var currentPoint = new Point(position);\n  var feature = new Feature(currentPoint);\n  vectorContext.drawFeature(feature, geoMarkerStyle);\n};\n\n//Test lat long : (48.857351 , 2.337242)\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}